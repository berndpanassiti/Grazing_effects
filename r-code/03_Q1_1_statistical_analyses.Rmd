---
title: "Statistical analyses to evaluate the influence of grazing and environment on insect diversity"
author: "Bernd Panassiti"
date: 'created: 07.06.2023, last modified: `r format(Sys.Date(), format="%d.%m.%Y")`'
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---



```{r setup, include=FALSE}
library(knitr)
opts_knit$set(root.dir='../')                     # definining working directory; or normalizePath('../')
opts_chunk$set(fig.align='center',                # aligns all figures
                echo=TRUE,                        # shows r-code
                message=FALSE,                    # suppresses library outputs
                warnings=FALSE,                   # suppresses library outputs
                tidy=TRUE,  # prevents the source code from running off a pdf page
                dev='pdf')                        # pdf device
```




# Introduction

This script provides the R-code for the statistical analyses to evaluate the influence of grazing time on insect diversity in alpine pastures.

2 hypotheses are investigated:

1) Influence of grazing time (early, late) on insect diversity depending on survey period and year
2)


Reponse data: taxonomic, phylogenetic and functional alpha diversity of Apiformes, Papilionoidea, Auchenorrhyncha

Using iNEXT3d estimates, I assume that respones follows a Gaussian distribution


With random effect

(1 | A/B) translates to (1 | A) + (1 | A:B) where A:B simply means creating a new grouping factor with the levels of A and B pasted together:
If the user were to write (1 | g1/g2), brms will expand this to (1 | g1) + (1 | g1:g2)
https://journal.r-project.org/archive/2018/RJ-2018-017/index.html

lmer:
https://www.phonetik.uni-muenchen.de/~jmh/lehre/sem/ss18/statistikR_files/MixedModels.html

https://ourcodingclub.github.io/tutorials/mixed-models/

for model formulation of interaction of two factor variables see:
https://stackoverflow.com/questions/40729701/how-to-use-formula-in-r-to-exclude-main-effect-but-retain-interaction




# Loading of packages and data
```{r loading_data, include=FALSE}
#Install/load pacman
if(!require(pacman)){install.packages("pacman");require(pacman)}
#Install packages
p_load(tidyverse,magrittr,caret,ggplot2,DHARMa,broom.mixed,
       posterior,ggdist,tidybayes,pryr,bayesplot,ggpubr,grid,gridExtra,
       emmeans,broom, broom.mixed,
       posterior,brms,bayesplot,ggpubr,
       hrbrthemes,patchwork,# additional themes
       GGally) # ggpairs

source("r-code/00_functions.R")

load("data/workingdata.RData")
```


# Fitting of Linear mixed models
## Specify model parameters
```{r}
family=gaussian()
myIter = 30000 # number of MCMC samples
myThin = 10 # thinning in case of strong autocorrelation of Markov chains
myChains = 4 # number of Markov chains
mySeed = 2022 # sets the internal random number generator seed to allow reproducibility
# control: tuning parameter in the NUTS sampler for Hamiltonian Monte Carlo, can be raised in case of divergent transitions, btw 0 and 1, default: 0.8
myPriors = c(prior(normal(0,10),class="Intercept"),
             prior(normal(0,10),class="b"))
controlList = list(adapt_delta = 0.9999, max_treedepth = 15)
```

## Insect model - Management predictors
### Fitting models
```{r}
rm(.Random.seed, envir=globalenv())
set.seed(2023)

make_model <- function(y) brms::brm(
  y[['formula']], 
  data=model_data,
              family=family,iter = myIter, thin = myThin, chains = myChains,
              seed=mySeed, control=controlList,
              save_pars = save_pars(all = TRUE))

# TD management
model_specs <- list(
  ## bee
  bee.TD.q0 = list(formula = brmsformula(beeTDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled+ (1 |siteID))),
  ## butterfly
  butterfly.TD.q0 = list(formula = brmsformula(butterflyTDq0 ~ surveyPeriod +
                                                 grazingTime:surveyPeriod +
                                                 year+elevationScaled+ (1 |siteID))),
  ## planthopper
  planthopper.TD.q0 = list(formula = brmsformula(planthopperTDq0 ~ surveyPeriod +
                                                  grazingTime:surveyPeriod + 
                                                  elevationScaled+ (1 |siteID)))
  )

  
modelResultsTDManagement <- model_specs  %>% Map(f = make_model) 



  # FD management
model_specs <- list(
  ## bee
  bee.FD.q0 = list(formula = brmsformula(beeFDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled+ (1 |siteID))),
  ## butterfly
  butterfly.FD.q0 = list(formula = brmsformula(butterflyFDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled+ (1 |siteID))),
  ## planthopper
  planthopper.FD.q0 = list(formula = brmsformula(planthopperFDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           elevationScaled+ (1 |siteID)))
  )

  
modelResultsFDManagement <- model_specs  %>% Map(f = make_model) 



  # PD management
model_specs <- list(
  ## bee
  bee.PD.q0 = list(formula = brmsformula(beePDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled + (1 |siteID))),
  ## butterfly
  butterfly.PD.q0 = list(formula = brmsformula(butterflyPDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled + (1 |siteID))),
  ## planthopper
  planthopper.PD.q0 = list(formula = brmsformula(planthopperPDq0 ~ surveyPeriod + grazingTime:surveyPeriod +
                                           elevationScaled + (1 |siteID)))
  )

  
modelResultsPDManagement <- model_specs  %>% Map(f = make_model) 

```



### Plot of Estimates
prob.outer = 95%
prob = 90%
```{r}
# TD
n = names(modelResultsTDManagement)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsTDManagement[[nameindex]],
                variable = c( "^b_", "^sd_"), 
                regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), 
                tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)


plot_list[[1]] = plot_list[[1]] + scale_y_discrete(labels= Labels, limits = rev)
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev)

# no axis labels for butterfly plot
plot_list[[2]] = plot_list[[2]]+
                 theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())

plotEstimatesTD = ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,0.5),ncol=3)

# PD
n = names(modelResultsPDManagement)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsPDManagement[[nameindex]],
                variable = c( "^b_", "^sd_"), regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)


plot_list[[1]] = plot_list[[1]] + scale_y_discrete(labels= Labels, limits = rev)
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev)

# no axis labels for butterfly plot
plot_list[[2]] = plot_list[[2]]+
                 theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())


plotEstimatesPD = ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,0.5),ncol=3)

# FD
n = names(modelResultsFDManagement)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsFDManagement[[nameindex]],
                variable = c( "^b_", "^sd_"), regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)


plot_list[[1]] = plot_list[[1]] + scale_y_discrete(labels= Labels, limits = rev)
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev)

# no axis labels for butterfly plot
plot_list[[2]] = plot_list[[2]]+
                 theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())


plotEstimatesFD = ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,0.5),ncol=3)




pdf(file=paste("figures/",gsub("-",".",Sys.Date()),"-Q1 - insectManagement - Estimates.pdf",sep=""),w= 20, h=10)
plotEstimatesTD
plotEstimatesPD
plotEstimatesFD
dev.off()
```


## Vegetation model - Management predictors
### Flower & Height
####Fitting models
```{r}
rm(.Random.seed, envir=globalenv())
set.seed(2023)

make_model <- function(y) brms::brm(
  y[['formula']], 
  data=model_data,
              family=family,iter = myIter, thin = myThin, chains = myChains,
              seed=mySeed, control=controlList,
              save_pars = save_pars(all = TRUE))

# Vegetation management
model_specs <- list(
  vegFlower = list(formula = brmsformula(nInflorescenceCoocc ~ surveyPeriod + grazingTime:surveyPeriod +
                                           year+elevationScaled+ (1 |siteID))),
  
  # height only available for 2021, not 2022! so no need for year as fixed factor
  vegHeight = list(formula = brmsformula(height ~ surveyPeriod +grazingTime:surveyPeriod +
                                                 elevationScaled+ (1 |siteID)))
  )

  
modelResultsVegManagement <- model_specs  %>% Map(f = make_model) 
```


#### Plot of Estimates
prob.outer = 95%
prob = 90%
```{r}
n = names(modelResultsVegManagement)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsVegManagement[[nameindex]],
                variable = c( "^b_", "^sd_"), 
                regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), 
                tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

for (i in 1:5){
plot_list[[i]] = plot_list[[i]] + scale_y_discrete(labels= Labels, limits = rev)}


for (i in c(2,3,4,5)){
plot_list[[i]] = plot_list[[i]]+
           theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())}

ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,0.5,0.5,0.5),ncol=5)
```




## Insect model - Vegetation predictors 
### Fitting models
```{r}
rm(.Random.seed, envir=globalenv())
set.seed(2023)

make_model <- function(y) brms::brm(
  y[['formula']], 
  data=model_data,
              family=family,iter = myIter, thin = myThin, chains = myChains,
              seed=mySeed, control=controlList,
              save_pars = save_pars(all = TRUE))

# TD
model_specs <- list(
# bee
  bee.TD.q0 = list(formula = brmsformula(log(beeTDq0+1) ~ surveyPeriod + 
                                           nInflorescenceCoocc : surveyPeriod + 
                                           year + elevationScaled + (1|siteID))),
# butterfly
  butterfly.TD.q0 = list(formula = brmsformula(log(butterflyTDq0+1) ~ surveyPeriod + 
                                           nInflorescenceCoocc : surveyPeriod + 
                                           year + elevationScaled + (1|siteID))),
# planthopper

planthopper.TD.q0 = list(formula = brmsformula(log(planthopperTDq0+1) ~ surveyPeriod + 
                                           height  : surveyPeriod + 
                                           elevationScaled + (1|siteID)))

)

modelResultsTDVegetation <- model_specs  %>% Map(f = make_model) 


# PD
model_specs <- list(
# bee
bee.PD.q0 = list(formula = brmsformula(log(beePDq0+1) ~ surveyPeriod + 
                                          nInflorescenceCoocc : surveyPeriod + 
                                          year + elevationScaled + (1|siteID))),
# butterfly
butterfly.PD.q0 = list(formula = brmsformula(log(butterflyPDq0+1) ~ surveyPeriod + 
                                          nInflorescenceCoocc : surveyPeriod + 
                                          year + elevationScaled + (1|siteID))),
# planthopper
planthopper.PD.q0 = list(formula = brmsformula(log(planthopperPDq0+1) ~ surveyPeriod + 
                                          height: surveyPeriod + 
                                          elevationScaled + (1|siteID))))

modelResultsPDVegetation <- model_specs  %>% Map(f = make_model) 

# FD
model_specs <- list(
# bee
  bee.FD.q0 = list(formula = brmsformula(log(beeFDq0+1) ~ surveyPeriod + 
                                           nInflorescenceCoocc : surveyPeriod + 
                                           year + elevationScaled + (1|siteID))),
# butterfly
  butterfly.FD.q0 = list(formula = brmsformula(log(butterflyFDq0+1) ~ surveyPeriod + 
                                           nInflorescenceCoocc : surveyPeriod + 
                                           year + elevationScaled + (1|siteID))),
# planthopper
planthopper.FD.q0 = list(formula = brmsformula(log(planthopperFDq0+1) ~ surveyPeriod + 
                                           height  : surveyPeriod + 
                                           elevationScaled + (1|siteID))))

modelResultsFDVegetation <- model_specs  %>% Map(f = make_model) 
```

### Plots of Estimates
```{r}
n = names(modelResultsTDVegetation)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsTDVegetation[[nameindex]],
                variable = c( "^b_", "^sd_"), regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)


plot_list[[1]] = plot_list[[1]] + scale_y_discrete(labels= Labels, limits = rev) # pollinator
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev) # planthopper

# no axis labels for butterfly plot
plot_list[[2]] = plot_list[[2]]+
                 theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())

rm(p1)
p1 = ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,1),ncol=3)



# FD
n = names(modelResultsFDVegetation)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsFDVegetation[[nameindex]],
                variable = c( "^b_", "^sd_"), regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)

for (i in 1:2){
plot_list[[i]] = plot_list[[i]] + scale_y_discrete(labels= Labels, limits = rev)}
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev)


for (i in c(2)){
plot_list[[i]] = plot_list[[i]]+
           theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())}

rm(p2)
p2=ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,1),ncol=3)


# PD
n = names(modelResultsPDVegetation)

plot_list = lapply(setNames(n, n), function(nameindex) {mcmc_plot(modelResultsPDVegetation[[nameindex]],
                variable = c( "^b_", "^sd_"), regex = T,prob_outer = 0.95,prob=0.9) +
                labs(title = gsub("[.]"," ",nameindex), tag = "")})

Labels = as.character(plot_list[[1]]$data$parameter)
Labels = gsub("b_","",Labels)
Labels[which(Labels =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels= rev(Labels)

Labels2 = as.character(plot_list[[3]]$data$parameter)
Labels2 = gsub("b_","",Labels2)
Labels2[which(Labels2 =="sd_siteID__Intercept")] ="sd siteID (Intercept)"
Labels2= rev(Labels2)

for (i in 1:2){
plot_list[[i]] = plot_list[[i]] + scale_y_discrete(labels= Labels, limits = rev)}
plot_list[[3]] = plot_list[[3]] + scale_y_discrete(labels= Labels2, limits = rev)


for (i in c(2)){
plot_list[[i]] = plot_list[[i]]+
           theme(axis.ticks.y = element_blank(),
                 axis.text.y=element_blank())}

rm(p3)
p3=ggpubr::ggarrange(plotlist=plot_list,widths = c(1, 0.5,1),ncol=3)



pdf(file=paste("figures/",gsub("-",".",Sys.Date()),"-Q1 - insectVegetation - Estimates.pdf",sep=""),w= 20, h=10)
p1
p2
p3
dev.off()
```




# Table with estimates
```{r}
# management
modelEstimatesTDManagement = modelResultsTDManagement %>% lapply(function(x) broom::tidy(x))
datTD = list_rbind(modelEstimatesTDManagement, names_to = "id")
modelEstimatesPDManagement = modelResultsPDManagement %>% lapply(function(x) broom::tidy(x))
datPD = list_rbind(modelEstimatesPDManagement, names_to = "id")
modelEstimatesFDManagement = modelResultsFDManagement %>% lapply(function(x) broom::tidy(x))
datFD = list_rbind(modelEstimatesFDManagement, names_to = "id")

datManagement = bind_rows(datTD,datPD,datFD)
datManagement$modelType = "management" 


# vegetation
modelEstimatesTDVegetation = modelResultsTDVegetation %>% lapply(function(x) broom::tidy(x))
datTD = list_rbind(modelEstimatesTDVegetation, names_to = "id")
modelEstimatesPDVegetation = modelResultsPDVegetation %>% lapply(function(x) broom::tidy(x))
datPD = list_rbind(modelEstimatesPDVegetation, names_to = "id")
modelEstimatesFDVegetation = modelResultsFDVegetation %>% lapply(function(x) broom::tidy(x))
datFD = list_rbind(modelEstimatesFDVegetation, names_to = "id")

datVegetation = bind_rows(datTD,datPD,datFD)
datVegetation$modelType = "vegetation" 

dat = rbind(datManagement,datVegetation)


dat$group = as.character(sapply(dat$id, function(x) str_split(x,"\\.")[[1]][1]))
dat$divType = as.character(sapply(dat$id, function(x) 
                str_split(x,"\\.")[[1]][2]))
dat$hillNumber = as.numeric(sapply(dat$id, function(x)
                  gsub("q","",str_split(x,"\\.")[[1]][3])))

dat %<>% dplyr::select(-id,-effect,-component)

modelEstimates= arrange.vars(dat, c("modelType"=2, "divType"=3, "hillNumber"=4))

modelEstimates  %<>% tibble::add_column(effectNoteworthy=NA)


for(i in 1:nrow(modelEstimates)){
  if(isTRUE(data.table::between(0,modelEstimates$conf.low[i],modelEstimates$conf.high[i]))){
   modelEstimates$effectNoteworthy[i] = 0}else{
   modelEstimates$effectNoteworthy[i] = 1}
}
```







# Export in excel table

2 tables: management and vegetation
## Management
### Estimates
```{r}
datTD = list_rbind(modelEstimatesTDManagement, names_to = "id")
datPD = list_rbind(modelEstimatesPDManagement, names_to = "id")
datFD = list_rbind(modelEstimatesFDManagement, names_to = "id")
df = bind_rows(datTD,datPD,datFD)
df$modelType = "management" 

# Intercept surveyPeriod2 year2022 elevation sp1xEarly sp2xEarly sp1xLate sp2xLate


df  %<>% tibble::add_column(effectNoteworthy=NA)


for(i in 1:nrow(df)){
  if(isTRUE(data.table::between(0,df$conf.low[i],df$conf.high[i]))){
   df$effectNoteworthy[i] = ""}else{
   df$effectNoteworthy[i] = "*"}
}


df %<>% mutate(estimateNew = paste(my_signif(estimate)," (",my_signif(std.error),")",effectNoteworthy,sep=""),
                   conf = paste("(",my_signif(conf.low),", ",my_signif(conf.high),")",sep="")
                   )

df %<>%dplyr::select(-effect,-component,-group,-modelType, -estimate,-std.error,-conf.low,-conf.high,-effectNoteworthy)


df1 = df %>% pivot_wider(id_cols = id,names_from = term,values_from = c("estimateNew","conf"))

# renaming for columns
names(df1) =  gsub("estimateNew_","",names(df1))

df2 = df1%>%dplyr::rename(
  Intercept = '(Intercept)',
  sp1xEarly='surveyPeriod1:grazingTimeearly',
  sp2xEarly='surveyPeriod2:grazingTimeearly',
  sp1xLate='surveyPeriod1:grazingTimelate',
  sp2xLate='surveyPeriod2:grazingTimelate',
  sd_Intercept = 'sd__(Intercept)',
  sd_Obs = 'sd__Observation',
  conf_Intercept = 'conf_(Intercept)',
  conf_sp1xEarly = 'conf_surveyPeriod1:grazingTimeearly',
  conf_sp2xEarly = 'conf_surveyPeriod2:grazingTimeearly',
  conf_sp1xLate = 'conf_surveyPeriod1:grazingTimelate',
  conf_sp2xLate = 'conf_surveyPeriod2:grazingTimelate',
  conf_sd_Intercept = 'conf_sd__(Intercept)',              
  conf_sd_Obs = 'conf_sd__Observation'              
)

# final noteworthy table
df2  %<>% tibble::add_column(effectNoteworthy=0)


for(i in 1:nrow(df2)){
  if(any(sapply(df2[i,3:9], function(x) grepl("\\*",x)))){
   df2$effectNoteworthy[i] = 1}
}
```


### Performance
```{r}
rm(.Random.seed, envir=globalenv())
set.seed(2023)
modelPerformanceTDManagement = modelResultsTDManagement %>% lapply(function(x) performance::model_performance(x))
modelPerformancePDManagement = modelResultsPDManagement %>% lapply(function(x) performance::model_performance(x))
modelPerformanceFDManagement = modelResultsFDManagement %>% lapply(function(x) performance::model_performance(x))

# Response residuals not available to calculate mean square error. (R)MSE is probably not reliable.

dfModelPerformanceTDManagement = as_tibble(do.call(rbind, modelPerformanceTDManagement))
dfModelPerformanceTDManagement$id = names(modelPerformanceTDManagement)
dfModelPerformancePDManagement = as_tibble(do.call(rbind, modelPerformancePDManagement))
dfModelPerformancePDManagement$id = names(modelPerformancePDManagement)
dfModelPerformanceFDManagement = as_tibble(do.call(rbind, modelPerformanceFDManagement))
dfModelPerformanceFDManagement$id = names(modelPerformanceFDManagement)

dfModelPerformanceManagement = bind_rows(dfModelPerformanceTDManagement,
                                         dfModelPerformancePDManagement ,
                                         dfModelPerformanceFDManagement)
```

### Prepare for Excel-Export
```{r}
df3 = merge(df2,dfModelPerformanceManagement,by="id")

df3$group = as.character(sapply(df3$id, function(x) str_split(x,"\\.")[[1]][1]))
df3$divType = as.character(sapply(df3$id, function(x) 
                str_split(x,"\\.")[[1]][2]))
df3$hillNumber = as.numeric(sapply(df3$id, function(x)
                  gsub("q","",str_split(x,"\\.")[[1]][3])))

df3 %<>% dplyr::select(-id)
resultsExcelManagement = arrange.vars(df3, c("group"=1, "divType"=2, "hillNumber"=3))

resultsExcelManagement[,25:36] = apply(resultsExcelManagement[,25:36],2,my_signif)


resultsExcelManagement = as_tibble(resultsExcelManagement)
```


## Vegetation
### Estimates
```{r}
datTD = list_rbind(modelEstimatesTDVegetation, names_to = "id")
datPD = list_rbind(modelEstimatesPDVegetation, names_to = "id")
datFD = list_rbind(modelEstimatesFDVegetation, names_to = "id")
df = bind_rows(datTD,datPD,datFD)
df$modelType = "vegetation" 

# Intercept surveyPeriod2 year2022 elevation sp1xEarly sp2xEarly sp1xLate sp2xLate


df  %<>% tibble::add_column(effectNoteworthy=NA)


for(i in 1:nrow(df)){
  if(isTRUE(data.table::between(0,df$conf.low[i],df$conf.high[i]))){
   df$effectNoteworthy[i] = ""}else{
   df$effectNoteworthy[i] = "*"}
}


df %<>% mutate(estimateNew = paste(my_signif(estimate)," (",my_signif(std.error),")",effectNoteworthy,sep=""),
                   conf = paste("(",my_signif(conf.low),", ",my_signif(conf.high),")",sep="")
                   )

df %<>%dplyr::select(-effect,-component,-group,-modelType, -estimate,-std.error,-conf.low,-conf.high,-effectNoteworthy)


df1 = df %>% pivot_wider(id_cols = id,names_from = term,values_from = c("estimateNew","conf"))

# renaming for columns
names(df1) =  gsub("estimateNew_","",names(df1))

df2 = df1%>%dplyr::rename(
  Intercept = '(Intercept)',
  sp1xInflor='surveyPeriod1:nInflorescenceCoocc',
  sp2xInflor='surveyPeriod2:nInflorescenceCoocc',
  sp1xHeight='surveyPeriod1:height',
  sp2xHeight='surveyPeriod1:height',
  sd_Intercept = 'sd__(Intercept)',
  sd_Obs = 'sd__Observation',
  conf_Intercept = 'conf_(Intercept)',
  conf_sp1xInflor='conf_surveyPeriod1:nInflorescenceCoocc',
  conf_sp2xInflor='conf_surveyPeriod2:nInflorescenceCoocc',
  conf_sp1xHeight='conf_surveyPeriod1:height',
  conf_sp2xHeight='conf_surveyPeriod1:height',
  conf_sd_Intercept = 'conf_sd__(Intercept)',              
  conf_sd_Obs = 'conf_sd__Observation'              
)

# final noteworthy table
df2  %<>% tibble::add_column(effectNoteworthy=0)


for(i in 1:nrow(df2)){
  if(any(sapply(df2[i,3:9], function(x) grepl("\\*",x)))){
   df2$effectNoteworthy[i] = 1}
}
```


### Performance
```{r}
rm(.Random.seed, envir=globalenv())
set.seed(2023)
modelPerformanceTDVegetation = modelResultsTDVegetation %>% lapply(function(x) performance::model_performance(x))
modelPerformancePDVegetation = modelResultsPDVegetation %>% lapply(function(x) performance::model_performance(x))
modelPerformanceFDVegetation = modelResultsFDVegetation %>% lapply(function(x) performance::model_performance(x))

# Response residuals not available to calculate mean square error. (R)MSE is probably not reliable.

dfModelPerformanceTDVegetation = as_tibble(do.call(rbind, modelPerformanceTDVegetation))
dfModelPerformanceTDVegetation$id = names(modelPerformanceTDVegetation)
dfModelPerformancePDVegetation = as_tibble(do.call(rbind, modelPerformancePDVegetation))
dfModelPerformancePDVegetation$id = names(modelPerformancePDVegetation)
dfModelPerformanceFDVegetation = as_tibble(do.call(rbind, modelPerformanceFDVegetation))
dfModelPerformanceFDVegetation$id = names(modelPerformanceFDVegetation)

dfModelPerformanceVegetation = bind_rows(dfModelPerformanceTDVegetation,
                                         dfModelPerformancePDVegetation,
                                         dfModelPerformanceFDVegetation)
```

### Prepare for Excel-Export
```{r}
df3 = merge(df2,dfModelPerformanceVegetation,by="id")

df3$group = as.character(sapply(df3$id, function(x) str_split(x,"\\.")[[1]][1]))
df3$divType = as.character(sapply(df3$id, function(x) 
                str_split(x,"\\.")[[1]][2]))
df3$hillNumber = as.numeric(sapply(df3$id, function(x)
                  gsub("q","",str_split(x,"\\.")[[1]][3])))

df3 %<>% dplyr::select(-id)
resultsExcelVegetation= arrange.vars(df3, c("group"=1, "divType"=2, "hillNumber"=3))

resultsExcelVegetation[,25:36] = apply(resultsExcelVegetation[,25:36],2,my_signif)


resultsExcelVegetation = as_tibble(resultsExcelVegetation)
```



## Export to excel
```{r}
wb <- openxlsx::createWorkbook()

openxlsx::addWorksheet(wb, "Management")
openxlsx::addWorksheet(wb, "Vegetation")
openxlsx::writeData(wb, sheet = "Management",resultsExcelManagement)
openxlsx::writeData(wb, sheet = "Vegetation",resultsExcelVegetation)

openxlsx::saveWorkbook(wb, paste("results/",gsub("-",".",Sys.Date()),
                            "-Q1_modelResults-Estimates-Performance.xlsx",sep=""), overwrite = FALSE)
```



# Save model results
```{r}
save(model_data,
     # insect response, management predictors
     modelResultsTDManagement,modelResultsFDManagement,modelResultsPDManagement,
     modelEstimatesTDManagement,modelEstimatesPDManagement,modelEstimatesFDManagement,
     resultsExcelManagement,
     beePlotManagement,butterflyPlotManagement,planthopperPlotManagement,
     
     # insect response, vegetation predictors
     modelResultsTDVegetation,modelResultsFDVegetation,modelResultsPDVegetation,
     modelEstimatesTDVegetation,modelEstimatesPDVegetation,modelEstimatesFDVegetation,
     resultsExcelVegetation,
     
     modelEstimates, # table with combined estimates from management and vegetation model
     
     # vegetation response, management predictors
     modelResultsVegManagement,
     file="results/modelResults.RData")
```

